#  8. 의존관계 자동주입

## 다양한 의존 관계 주입 방법
1. 생성자 주입
2. Setter(수정자) 주입
3. 필드 주입
4. 일반 메서드 주입

### 1. 생성자 주입
>지금 까지 우리는 Component 클래스 내에 생성자를 만들고 이를 통해 AppConfig.class를 통하여 의존관계를 주입해왔다.
물론 @Component @ComponentScan @Autowired를 활용한 AutoAppConfig.class방식으로 주입해왔다.   
이러한 방식을 생성자 주입 방법이라고 한다.
```java
@Component
public class PaymentServiceImpl implements PaymentServiceA {
     private final SomeRepository someRepository;
     private final SomeService someService;
     @Autowired //생성자가 1개만 있으면 생략가능.. 요즘은 잘 안쓰기도 한다.
     public OrderServiceImpl(SomeService someService, SomeRepository someRepository) {
         this.someService = someService;
         this.someRepository = someRepository;
     }
}
```

### 2. 수정자 주입
>Getter, Setter의 Setter를 이용한 주입 방법이다. setter 메서드를 만들고 @Autowired를 붙여준다.
세터의 경우 @Autowired(required=false)로 필수적이지 않은 의존관계를 생성할 수 있다.
```java
@Component
public class PaymentServiceImpl implements PaymentService {
    private SomeRepository someRepository;
    private SomeSerivce someSerivce;
    @Autowired
    public void setSomeRepository(SomeRepository someRepository) {
        this.someRepository = someRepository;
    }
    @Autowired
    public void setSomePolicy(SomeService someSerivce){
        this.someSerivce = someSerivce;
    }
}
```

### 3. 필드 주입 (Not Recommended)
> @Autowired를 변수 선언 앞에 붙여주는 방식, 일반적으로 필드 주입은 인텔리제이 자체에서도 권장하지 않는 방법인데 그 이유는 테스트가 힘들기 때문이다.


  아래 코드를 보면 외부에서 수정을 할 수가 없다. 예를들어 SomeRepository말고 다른 MemoryRepository와 같이 테스트를 위해서 잠깐 바꾸고 싶은데 바꿀 수 없다.
```java
@Component
public class PaymentServiceImpl implements PaymentService {
    @Autowired  private SomeRepository someRepository;
    @Autowired  private SomeSerivce someSerivce;
}
```

### 4. 일반 메서드 주입
> 그냥 생성자 대신 일반 메서드를 통해서 주입 받는 방식. @Autowired를 그냥 일반 메서드에 붙여주고 주입하면 된다. 생성자 쓰는게 더 보기 좋으므로 잘 안쓴다.

***
## 옵션 처리
- @Autowired(required = false) 아예 만들어지지 않음.
- Optional 사용 Optional.empty가 생성됨
- @Nullable 사용 null값이 들어감

***
## 의존 관계 주입 무엇을 써야하나?
> 수정자 주입을 사용하게 되면 테스트할때 코드를 직접 들어가봐야만 내가 테스트하려는 서비스의 구현체에 어떤것이 의존관계로 엮여있는지  
즉 내가 테스트할 서비스의 객체를 만들때 어떠한 객체를 추가적으로 생성해서 부여해줘야하는지 쉽게 알 수가 없다.  
**생성자를 사용하자**
```java
    @Test
    void creteOrder(){
        /* 멤버 저장소에 멤버를 저장하는 과정 생략, 이것에 멤버 레포지터리 생성및 멤버 추가 작업*/
        OrderServiceImpl orderService = new OrderServiceImpl(MemoryMemberRepository(), new FixDiscountPolicy());
        orderService.createOrder(1L, "itemA", 10000);
    }
```
위와 같이 바로바로 내가 테스트할 서비스 구현체를 만들고 필요한 다른 의존관계를 테스트용으로써 즉석으로 주입이 가능하다.   
이로써 생성자를 사용하면 프레임워크 없이 순수 자바코드로써 해당 구현체를 테스트에서 직접 조립을 해서 테스트 해볼수가 있다.  
추가적으로 생성자를 사용하게 되면 final 키워드를 사용할 수가 있다.(수정자를 사용하고 final 키워드 사용시 에러 발생)  
final의 장점은 생성자에서만 값을 넣어줄 수 있다는 점이다. 그리고 final을 넣어주면 객체 초기화시에 반드시 값이 들어와야 해서   
만약 코드에 실수(생성자 메서드 내에 실수로 값이 설정되지 않을때)가 있다면 쉽게 컴파일할때 찾아낼 수 있다.  
**컴파일 오류는 좋은 오류!!**
> 생성자 주입이 좋은 방식이나 선택적으로 필수로 넣어줘야 하는 값이 포함되어 있는경우 생성자와 수정자를 동시에 사용하는 경우도 있다.  
이렇게 수정자는 필요하면 사용해도되는 경우가 있으나 필드 주입은 가급적 사용하지 않는다.  
***
